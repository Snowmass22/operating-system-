#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <vector>
using namespace std;


queue <int> buffer;
const int max_buffer_size=5;

mutex mtx;
condition_variable cv_producer;
condition_variable cv_consumer;

void producer(int id){
    for(int i=0;i<10;i++){
        unique_lock <mutex> lock(mtx);

        //check if the buffer is full
        cv_producer.wait(lock,[]{
            return buffer.size() < max_buffer_size;
        });
        int item=i+(id*100);
        buffer.push(item);
        cout<<"producer produced:"<<item<<endl;

        lock.unlock();
        cv_consumer.notify_one();

        this_thread::sleep_for(chrono::milliseconds(100));
    }
}

void consumer(int id){
    for(int i=0;i<10;i++){
        unique_lock <mutex> lock(mtx);

        //check if the buffer is empty

        cv_consumer.wait(lock,[]{
            return !buffer.empty();
        });

        int item=buffer.front();
        buffer.pop();
        cout<<"consumer consumed:"<<item;

        lock.unlock();

        cv_producer.notify_one();

        this_thread::sleep_for(chrono::milliseconds(150));
    }

}
int main(){
    thread t1(producer,1);
    thread t2(consumer,1);


    t1.join();
    t2.join();

    return 0;
}//
